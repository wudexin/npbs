package com.nantian.npbs.test.business.pos;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nantian.npbs.common.utils.ConvertUtils;

public class Pos010003SocketClient {

	private static final Logger logger = LoggerFactory
			.getLogger(Pos010003SocketClient.class);

	private final static ThreadLocal<Socket> sockPool = new ThreadLocal<Socket>();

	/** 决定客户端采用长连接还是短连接的方式 */
	private static final boolean KEEP_CONNECTION = false;

	public static void main(String args[]) throws Exception {
		sendSopBuffer(ConvertUtils.hexStr2Bytes(packet010003()));
		System.out.println("send 010003 OK!");

	}

	private static String packet010003() throws Exception {

		//return "01b3600018000060220000783008000020000104c0021900000300163033343031323334373420202020202060cbefd3c0c7bf202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202030353030303030322020202020202020202020200248303030303030303030303736373838393330303845463731463142304544383739413036334333314646433035374130413836363030303030303030303030303030303030303536303030303032323330303030303032313030303030303030303030303133313430313030303030303030303030303030303030303537303136333030303030303030303030303030202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202031303020202020202020202020202020595a44313032323031323031313631333030303138333120202020202020202001000314003132303131333030303039303835000000000000000000000000000000f406a8398cd79889";
		//return "01a4600018000060220000783002000020000104c0021900034600163039343137333435303320202020202060d3cad5feb2e2cad4bba72020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202030353531303032372020202020202020202020200248313033383234303030303030313930333030303046333830414333444441343939433446443346463745463935433838304132413030303030303030303030303030303030303039303030303030333930303030303033393030303030303030303030303030303030313030303030303030303030303030303030303030303030303030303030303030303030303030202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202031303020202020202020202020202020595a44313032323031323034323331333030313934323020202020202020202001000300143132303432333030323233323731c32dc1f5cfadcbfa";
		//return "01a460001883c660220000090102000020000104c0021900000600163033353238303939323620202020202060d6c7baea2020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202030353630393939392020202020202020202020200248303033333034303030303030313030333030303044304635393146374634414439383437413042344332354541364635433342333030303030303030303030303030303030303136303030303030303030303030303030303030303030303030303030303030303030313030303030303030303030303030303030303030303030303030303030303030303030303030202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202031303030202020202020202020202020595a44313032323031323034323531333032333435333520202020202020202001000300143132303432353230333935393239235e5d631434c31b";
		return "016b600018000060100000000002000020000104c0821900649700103033343031323334373406cbefd3c0c7bf313131312020202020202020202020202020202030353030383838392020202020202020202020203135360248303030303030303030303736373838393330303833314134323232423238343738323345463336434144363838354545343241382020202020202020202030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202032303020202020202020202020202020595a44313032323031323034323431333030323034303720202020202020202001000300143132303432343030323239393539ad6feb8e5af3489a";		
	}

	public static byte[] sendSopBuffer(byte[] buf) throws Exception {

		// 通过Socket连接服务器
		Socket server = getSocket();

		// 创建网络输出流输出内容到服务器上
		OutputStream netOut = server.getOutputStream();
		OutputStream dataOut = new BufferedOutputStream(netOut);

		byte[] serverbuf = new byte[2048];

		try {
			dataOut.write(buf, 0, buf.length);// 把文件数据写出网络缓冲区
			dataOut.flush();// 刷新缓冲区把数据写往服务器端

			InputStream netIn = server.getInputStream();
			InputStream dataIn = new BufferedInputStream(netIn);

			int servernum = dataIn.read(serverbuf);
			logger.info("从服务器读取的数据长度：{}" , servernum);
			if (servernum <= 0)
				throw new Exception("未能从前置读取有效数据！");

			/*
			 * while (servernum != (-1)) {
			 * logger.debug("continue reading from socket..."); servernum =
			 * dataIn.read(serverbuf);// 继续从网络中读取数据 }
			 */

			// 得到成功标志
			byte[] tmp = new byte[servernum];
			for (int i = 0; i < servernum; i++) {
				tmp[i] = serverbuf[i];
			}
			logger.info("result:{}" , new String(tmp));
			String ansHexString = ConvertUtils.bytes2HexStr(tmp);
			logger.info("result-hex, length[:{}]:{}",ansHexString.length() ,ansHexString);

		} catch (Exception e) {
			closeSocket();
			throw (e);
		} finally {
			if (!KEEP_CONNECTION) {
				closeSocket();
			}
		}

		return serverbuf;
	}

	private static Socket getSocket() throws UnknownHostException, IOException {
		Socket s = (Socket) sockPool.get();
		if (s == null || s.isClosed()) {
			logger.debug("s==null is " + (s == null));
			if (s != null)
				logger.debug("is closed:" + s.isClosed());
			s = reconnect();
			sockPool.set(s);
		}
		logger.info("Socket={} " , s.hashCode());
		return s;
	}

	private static Socket reconnect() throws UnknownHostException, IOException {
		logger.debug("recreating socket...");
		String serverIp = "127.0.0.1";
		int serverPort = 8884;
		Socket s = new Socket(serverIp, serverPort);
		s.setSoTimeout(10000000);
		logger.debug("socket recreated");
		return s;
	}

	public static void closeSocket() throws IOException {
		Socket s = (Socket) sockPool.get();
		sockPool.set(null);
		if (s != null && !s.isClosed()) {
			s.close();
		}
	}

}
